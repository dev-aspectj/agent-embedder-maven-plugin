<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from org.apache.maven.plugins:maven-plugin-report-plugin:3.11.0:report
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>Agent Embedder Maven Plugin &#x2013; agent-embedder:embed</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.11.1.min.js"></script>
    <style>.github-fork-ribbon:before { background-color: gray; }</style>
  </head>
  <body class="topBarDisabled">
    <a class="github-fork-ribbon right-top" href="https://github.com/dev-aspectj/agent-embedder-maven-plugin" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>Agent Embedder Maven Plugin</h1>
</div>
</div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
      <li class=""><a href="./index.html" title="Agent Embedder Maven Plugin">Agent Embedder Maven Plugin</a><span class="divider">/</span></li>
    <li class="active ">agent-embedder:embed</li>
      <li id="projectVersion" class="pull-right">Version: 1.0</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Overview</li>
    <li><a href="./index.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="./usage.html" title="Usage"><span class="none"></span>Usage</a></li>
    <li><a href="./plugin-info.html" title="Goals"><span class="none"></span>Goals</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<section>
<h2><a name="agent-embedder:embed"></a>agent-embedder:embed</h2><a name="agent-embedder:embed"></a>
<p><strong>Full name</strong>:</p>
<p>dev.aspectj:agent-embedder-maven-plugin:1.0:embed</p>
<p><strong>Description</strong>:</p>
<p>Embeds one or more java agents into the module's main artifact 
<p>Use this goal, if (and only if) you have an <b>executable JAR</b> (with a <code>Main-Class</code> attribute in its manifest) and wish to <b>run a java agent automatically</b> when running the JAR with <code>java -jar my.jar</code> on <b>JRE 9+</b>.</p>
<p>Normally, you would need an additional <code>-javaagent:/path/to/agent.jar</code> JVM argument, but since Java 9 there is the <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/instrument/package-summary.html"> <code>Launcher-Agent-Class</code> mechanism</a>. I.e., even though this plugin works just fine on Java 8, you do need to launch the modified executable JAR on JRE 9+ to enjoy the benefits of this JVM feature.</p>
<p>The <code>javaAgents</code><!-- no javadoc sites associated --> specified for this goal will be unpacked from their JARs and embedded into the main artifact's root directory to make them visible to the java agent classloader during runtime. JVM classloaders cannot load agents from nested JARs.</p>
<p>The main artifact is expected to exist already when executing this goal. Typically, the Maven module already uses another plugin creating a build artifact during the <code>package</code> phase, which is why this goal by default also runs in the same phase. Make sure to configure this plugin to run <i>after</i> the plugin creating the main artifact, so you have something for it to operate on. This can be done most easily by simply listing both plugins in the POM file in the desired chronological execution order, if they are to run in the same phase. Another option would be to let them run in different phases, making sure that this plugin runs later than the one creating the artifact. We recommend to stick to convention over configuration and use the <code>package</code> phase. For example:</p>
<pre><code>&lt;!-- Create executable Spring Boot fat JAR --&gt;
&lt;plugin&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
&lt;!-- Embed Java agent(s) for automatic execution --&gt;
&lt;plugin&gt;
  &lt;groupId&gt;dev.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;agent-embedder-maven-plugin&lt;/artifactId&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;embed-agents&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;embed&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;javaAgents&gt;
          &lt;!-- ... --&gt;
        &lt;/javaAgents&gt;
        &lt;removeEmbeddedAgents&gt;true&lt;/removeEmbeddedAgents&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p>Unique features not offered by the Java 9+ <code>Launcher-Agent-Class</code> mechanism:</p>
<ul>
 <li>Via <code>Launcher-Agent-Class</code>, the JVM only supports a single agent for auto-start, not multiple ones. Multiple agents can only be specified on the JVM command line. But this plugin installs its own launcher agent, which in turn is capable of starting <b>multiple java agents</b>.</li>
 <li><code>Launcher-Agent-Class</code> also does not support <b>agent option strings</b> like the JVM command line does. This plugin, however, does support agent arguments via its launcher agent. See the <code>javaAgents</code><!-- no javadoc sites associated --> section for more details.</li>
</ul></p>
<p><strong>Attributes</strong>:</p>
<ul>
<li>Requires a Maven project to be executed.</li>
<li>Requires dependency resolution of artifacts in scope: <code>compile+runtime</code>.</li>
<li>The goal is thread-safe and supports parallel builds.</li>
<li>Binds by default to the <a class="externalLink" href="https://maven.apache.org/ref/current/maven-core/lifecycles.html">lifecycle phase</a>: <code>package</code>.</li></ul><section>
<h3><a name="Required_Parameters"></a>Required Parameters</h3><a name="Required_Parameters"></a>
<table border="0" class="table table-striped">
<tr class="a">
<th>Name</th>
<th>Type</th>
<th>Since</th>
<th>Description</th></tr>
<tr class="b">
<td align="left"><a href="#javaAgents"><code>&lt;javaAgents&gt;</code></a></td>
<td><code>List&lt;JavaAgentInfo&gt;</code></td>
<td><code>-</code></td>
<td>Java agents to embed into the main artifact 
<p>Class <code>JavaAgentInfo</code><!-- no javadoc sites associated --> describes the properties available for describing artifacts. The following properties are available:</p>
<ul>
 <li><code>groupId</code>, <code>artifactId</code>, <code>classifier</code>: A java agent's Maven coordinates (without <code>version</code>), which are used to match a dependency declared for the module executing the plugin. If for any reason declaring the agent JAR a dependency is not an option, which should rarely be the case, see <code>agentPath</code> for a possible workaround.</li>
 <li><code>agentClass</code>: The agent class containing a <code>premain</code> launcher method. This property is optional, because by default the plugin extracts the value from the agent JAR's <code>Agent-Class</code> manifest attribute. In the rare occasion that you wish to override the manifest value (e.g., the manifest does not exist or does not contain the correct value), set this property.</li>
 <li><code>agentArgs</code>: An optional argument string for the java agent. When using <code>-javaagent</code> on the JVM command line, an argument string is specified after an equals sign, e.g. <code>-javaagent:/path/to/agent.jar=option1=one,option2=two</code>. This simply maps to an <code>agentArgs</code> value of <code>option1=one,option2=two</code>.</li>
 <li><code>agentPath</code>: Usually, the agent path is inferred from the corresponding dependency described by configuration values <code>groupId</code>, <code>artifactId</code>, <code>classifier</code>. This works for regular dependencies as well as system-scoped ones. But maybe, you have a special case where e.g. the agent JAR is stored in a libraries directory checked into the project's SCM (source code management) system. <i>(Please, avoid working like that!)</i> Then, you can specify <code>agentPath</code> to point there. Another case is that you know the path of a nested agent JAR inside the main artifact, e.g. <i>BOOT-INF/lib/agent.jar</i>, and for some weird reason the JAR got there without being a dependency. Again, you can specify <code>agentPath</code> to point there. The plugin will find and unpack the JAR from there.</li>
</ul> Here is an example for two agents to be embedded into the executable JAR, one of them also taking an option string: 
<pre><code>&lt;javaAgents&gt;
  &lt;agent&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;/agent&gt;
  &lt;agent&gt;
    &lt;groupId&gt;dev.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;remove-final-agent&lt;/artifactId&gt;
    &lt;!-- Optional parameter, overriding agent manifest value --&gt;
    &lt;agentClass&gt;dev.aspectj.agent.NonManifestRemoveFinalAgent&lt;/agentClass&gt;
    &lt;agentArgs&gt;dev.aspectj.FirstComponent,dev.aspectj.SecondComponent&lt;/agentArgs&gt;
  &lt;/agent&gt;
&lt;/javaAgents&gt;
</code></pre> This is an agent with dummy Maven coordinates and an agent path relative to the module base directory: 
<pre>&lt;javaAgents&gt;
  &lt;agent&gt;
    &lt;groupId&gt;dummy&lt;/groupId&gt;
    &lt;artifactId&gt;dummy&lt;/artifactId&gt;}
    &lt;agentPath&gt;${project.basedir}/lib/agent.jar&lt;/agentClass&gt;
  &lt;/agent&gt;
&lt;/javaAgents&gt;
</pre> This is an agent with dummy Maven coordinates and an agent path inside the executable JAR, plus an option string: 
<pre><code>&lt;javaAgents&gt;
  &lt;agent&gt;
    &lt;groupId&gt;dummy&lt;/groupId&gt;
    &lt;artifactId&gt;dummy&lt;/artifactId&gt;
    &lt;agentPath&gt;BOOT-INF/lib/agent.jar&lt;/agentClass&gt;
    &lt;agentArgs&gt;option1=one,option2=two&lt;/agentArgs&gt;
  &lt;/agent&gt;
&lt;/javaAgents&gt;
</code></pre></td></tr>
<tr class="a">
<td align="left"><a href="#removeEmbeddedAgents"><code>&lt;removeEmbeddedAgents&gt;</code></a></td>
<td><code>boolean</code></td>
<td><code>-</code></td>
<td>Remove nested agent JARs from the executable JAR after unpacking their contents into the executable JAR 
<p>Some executable JARs contain nested dependency JARs. For example, Spring Boot executable JARs contain some or all of their classpath dependencies in folder <i>BOOT-INF/lib</i>, from where they are loaded using a special classloader that can read nested JARs. Agent JARs defined as dependencies, e.g. <i>aspectjweaver-x.y.z.jar</i>, can also be found there, if the user did not exclude them during the build. After having expanded an agent JAR into the containing JAR's root folder, the classes exist twice in the same JAR - unpacked and as a nested JAR. This is not necessarily a big problem, but bloats the JAR.</p>
<p>This option, if active, makes the plugin search for nested JARs matching the names of artifacts described by <code>javaAgents</code>. For each agent, the first nested JAR found is deleted.</p><br /><strong>Default</strong>: <code>false</code></td></tr></table></section><section>
<h3><a name="Parameter_Details"></a>Parameter Details</h3><a name="Parameter_Details"></a><a name="javaAgents"><section>
<h4><a name="a.3CjavaAgents.3E"></a>&lt;javaAgents&gt;</h4><a name="a.3CjavaAgents.3E"></a></a>
<div>Java agents to embed into the main artifact 
<p>Class <code>JavaAgentInfo</code><!-- no javadoc sites associated --> describes the properties available for describing artifacts. The following properties are available:</p>
<ul>
 <li><code>groupId</code>, <code>artifactId</code>, <code>classifier</code>: A java agent's Maven coordinates (without <code>version</code>), which are used to match a dependency declared for the module executing the plugin. If for any reason declaring the agent JAR a dependency is not an option, which should rarely be the case, see <code>agentPath</code> for a possible workaround.</li>
 <li><code>agentClass</code>: The agent class containing a <code>premain</code> launcher method. This property is optional, because by default the plugin extracts the value from the agent JAR's <code>Agent-Class</code> manifest attribute. In the rare occasion that you wish to override the manifest value (e.g., the manifest does not exist or does not contain the correct value), set this property.</li>
 <li><code>agentArgs</code>: An optional argument string for the java agent. When using <code>-javaagent</code> on the JVM command line, an argument string is specified after an equals sign, e.g. <code>-javaagent:/path/to/agent.jar=option1=one,option2=two</code>. This simply maps to an <code>agentArgs</code> value of <code>option1=one,option2=two</code>.</li>
 <li><code>agentPath</code>: Usually, the agent path is inferred from the corresponding dependency described by configuration values <code>groupId</code>, <code>artifactId</code>, <code>classifier</code>. This works for regular dependencies as well as system-scoped ones. But maybe, you have a special case where e.g. the agent JAR is stored in a libraries directory checked into the project's SCM (source code management) system. <i>(Please, avoid working like that!)</i> Then, you can specify <code>agentPath</code> to point there. Another case is that you know the path of a nested agent JAR inside the main artifact, e.g. <i>BOOT-INF/lib/agent.jar</i>, and for some weird reason the JAR got there without being a dependency. Again, you can specify <code>agentPath</code> to point there. The plugin will find and unpack the JAR from there.</li>
</ul> Here is an example for two agents to be embedded into the executable JAR, one of them also taking an option string: 
<pre><code>&lt;javaAgents&gt;
  &lt;agent&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;/agent&gt;
  &lt;agent&gt;
    &lt;groupId&gt;dev.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;remove-final-agent&lt;/artifactId&gt;
    &lt;!-- Optional parameter, overriding agent manifest value --&gt;
    &lt;agentClass&gt;dev.aspectj.agent.NonManifestRemoveFinalAgent&lt;/agentClass&gt;
    &lt;agentArgs&gt;dev.aspectj.FirstComponent,dev.aspectj.SecondComponent&lt;/agentArgs&gt;
  &lt;/agent&gt;
&lt;/javaAgents&gt;
</code></pre> This is an agent with dummy Maven coordinates and an agent path relative to the module base directory: 
<pre>&lt;javaAgents&gt;
  &lt;agent&gt;
    &lt;groupId&gt;dummy&lt;/groupId&gt;
    &lt;artifactId&gt;dummy&lt;/artifactId&gt;}
    &lt;agentPath&gt;${project.basedir}/lib/agent.jar&lt;/agentClass&gt;
  &lt;/agent&gt;
&lt;/javaAgents&gt;
</pre> This is an agent with dummy Maven coordinates and an agent path inside the executable JAR, plus an option string: 
<pre><code>&lt;javaAgents&gt;
  &lt;agent&gt;
    &lt;groupId&gt;dummy&lt;/groupId&gt;
    &lt;artifactId&gt;dummy&lt;/artifactId&gt;
    &lt;agentPath&gt;BOOT-INF/lib/agent.jar&lt;/agentClass&gt;
    &lt;agentArgs&gt;option1=one,option2=two&lt;/agentArgs&gt;
  &lt;/agent&gt;
&lt;/javaAgents&gt;
</code></pre></div>
<ul>
<li><strong>Type</strong>: <code>java.util.List&lt;dev.aspectj.maven.agent_embedder.JavaAgentInfo&gt;</code></li>
<li><strong>Required</strong>: <code>Yes</code></li></ul><hr /></section><a name="removeEmbeddedAgents"><section>
<h4><a name="a.3CremoveEmbeddedAgents.3E"></a>&lt;removeEmbeddedAgents&gt;</h4><a name="a.3CremoveEmbeddedAgents.3E"></a></a>
<div>Remove nested agent JARs from the executable JAR after unpacking their contents into the executable JAR 
<p>Some executable JARs contain nested dependency JARs. For example, Spring Boot executable JARs contain some or all of their classpath dependencies in folder <i>BOOT-INF/lib</i>, from where they are loaded using a special classloader that can read nested JARs. Agent JARs defined as dependencies, e.g. <i>aspectjweaver-x.y.z.jar</i>, can also be found there, if the user did not exclude them during the build. After having expanded an agent JAR into the containing JAR's root folder, the classes exist twice in the same JAR - unpacked and as a nested JAR. This is not necessarily a big problem, but bloats the JAR.</p>
<p>This option, if active, makes the plugin search for nested JARs matching the names of artifacts described by <code>javaAgents</code>. For each agent, the first nested JAR found is deleted.</p></div>
<ul>
<li><strong>Type</strong>: <code>boolean</code></li>
<li><strong>Required</strong>: <code>Yes</code></li>
<li><strong>Default</strong>: <code>false</code></li></ul></section></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">

        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
